<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Card Continuum (JSON DB Simulation)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #06b6d4;
            --secondary-color: #374151;
            --track-start: #e0f2fe;
            --track-end: #06b6d4;
            --active-ring-color: #06b6d4;
            --active-glow-color: #06b6d4;
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for the 3D flip effect and modern shadows */
        .card-3d-wrapper {
            perspective: 1000px;
        }
        .flip-container {
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            position: relative;
        }
        .flip-container.flipped {
            transform: rotateY(180deg);
        }
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            padding: 0.75rem;
        }
        .card-front {
            background-color: white;
            border: 3px solid var(--track-start);
            z-index: 2;
        }
        .card-back {
            background-color: var(--secondary-color);
            border: 3px solid #1e40af;
            transform: rotateY(180deg);
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .shadow-glow-dynamic { 
            box-shadow: 0 0 15px var(--active-glow-color); 
        }
        .shadow-4xl {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.05);
        }
        .shadow-3xl {
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }
    </style>
</head>
<body class="bg-slate-50 p-4 sm:p-10">

    <div id="app" class="max-w-screen-xl mx-auto w-full">
        <!-- Header will be rendered here -->
        <header id="app-header" class="text-center mb-10 p-6 bg-white rounded-3xl shadow-3xl border-t-8" style="border-top-color: var(--primary-color)">
            <h1 class="text-4xl font-extrabold text-gray-800 mb-2 tracking-tight">Visual Card Continuum</h1>
            <p class="text-lg text-gray-500 font-light">
                Drag and drop the cards onto the continuum to reflect how much each statement is **Like You**.
            </p>
            <div class="flex justify-between items-center mt-4 text-sm text-gray-500 pt-2 border-t border-gray-100">
                <span>User ID: <span id="user-id-display" class="font-mono text-xs p-1 bg-gray-100 rounded-lg">Loading...</span></span>
                <div id="save-status" class="font-medium px-3 py-1 rounded-full transition-opacity duration-500 opacity-0"></div>
            </div>
        </header>

        <!-- Main Content (Loading or Error message) -->
        <div id="content-container">
            <div id="loading-spinner" class="text-center p-12 bg-white rounded-3xl shadow-2xl text-indigo-500">
                <svg class="animate-spin h-6 w-6 mr-3 inline" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none" stroke-dasharray="60" stroke-dashoffset="40" /></svg>
                Loading data...
            </div>
            <div id="error-message" class="hidden p-4 bg-red-100 text-red-700 rounded-xl mb-6 font-medium border-l-4 border-red-500"></div>
        </div>
    </div>

    <script>
        // --- CONSTANTS AND CONFIGURATION ---

        const APP_KEY = 'CardContinuum_NodeSim'; // Key for localStorage
        const STACK_INTERVAL = 3; 
        const CARD_VERTICAL_OFFSET = 110; 
        const DRAG_THRESHOLD = 5; 
        const APP_ID = 'node-sim-app-id'; // Simplified app ID for JSON structure

        const INITIAL_APP_CONFIG = {
            title: "Visual Card Continuum",
            primaryColor: "#06b6d4", 
            secondaryColor: "#374151", 
            trackGradientStart: "#e0f2fe", 
            trackGradientEnd: "#06b6d4", 
        };

        let appState = {
            config: INITIAL_APP_CONFIG,
            globalCards: [],
            cardData: [],
            userId: null,
            isDragging: false,
            activeCard: null,
            hasMoved: false,
            globalFlipped: false,
        };

        // --- UTILITY FUNCTIONS ---

        function uuidv4() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function assignDimensions(cards) {
            const dimensions = ['H', 'T', 'O', 'E'];
            const assignments = [];
            for (let dim of dimensions) {
                for (let i = 0; i < 10; i++) {
                    assignments.push(dim);
                }
            }

            for (let i = assignments.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [assignments[i], assignments[j]] = [assignments[j], assignments[i]];
            }

            return cards.map((card, index) => ({
                ...card,
                dimension: assignments[index % assignments.length],
                isFlipped: false, 
            }));
        }

        const INITIAL_MOCK_CARDS = assignDimensions(Array.from({ length: 40 }, (_, i) => ({
            id: `card_${i + 1}`,
            text: `I am a ${['Curious', 'Decisive', 'Creative', 'Analytical', 'Empathetic', 'Resilient'][i % 6]} person.`,
        })));

        function getDescription(value) {
            if (value === null) return 'Unplaced';
            if (value < 20) return 'Least Like Me';
            if (value < 40) return 'Slightly Unlike Me';
            if (value < 60) return 'Neutral / Sometimes Like Me';
            if (value < 80) return 'Mostly Like Me';
            return 'Most Like Me';
        }

        // --- SERVER/DB SIMULATION (Node.js/JSON) ---

        const serverDb = {
            // Simulates the JSON database structure
            // { appId: { config: {}, globalCards: [], users: { userId: { rankings: [] } } } }
        };

        function getUserId() {
            let userId = localStorage.getItem('node_sim_user_id');
            if (!userId) {
                userId = uuidv4();
                localStorage.setItem('node_sim_user_id', userId);
            }
            return userId;
        }

        // Function to load entire application state (simulates server startup/load)
        function loadAppState() {
            const storedData = localStorage.getItem(APP_KEY);
            if (storedData) {
                Object.assign(serverDb, JSON.parse(storedData));
            }
            
            // Ensure initial structure exists
            if (!serverDb[APP_ID]) {
                serverDb[APP_ID] = {
                    config: INITIAL_APP_CONFIG,
                    globalCards: INITIAL_MOCK_CARDS,
                    users: {},
                };
            }
        }

        // Simulates fetching configuration from the server DB
        function getServerConfig() {
            return serverDb[APP_ID].config;
        }

        // Simulates fetching global cards from the server DB
        function getServerGlobalCards() {
            return serverDb[APP_ID].globalCards;
        }

        // Simulates fetching user rankings from the server DB
        function getServerUserRankings(userId) {
            return serverDb[APP_ID].users[userId]?.rankings || [];
        }

        // Simulates saving the entire server DB state to persistence
        function saveServerDb() {
            localStorage.setItem(APP_KEY, JSON.stringify(serverDb));
        }

        // Simulates writing user rankings to the server DB
        function saveUserRankings(userId, rankings) {
            if (!serverDb[APP_ID].users[userId]) {
                serverDb[APP_ID].users[userId] = {};
            }
            serverDb[APP_ID].users[userId].rankings = rankings;
            saveServerDb();
        }

        // --- CORE DATA MERGE AND LOGIC ---

        function calculateStackedCards(allCards) {
            const placed = allCards.filter(c => c.position !== null);
            const unplacedCards = allCards.filter(c => c.position === null); 

            const groupedCards = placed
                .sort((a, b) => a.position - b.position)
                .reduce((acc, card) => {
                    const lastCluster = acc[acc.length - 1];
                    
                    if (lastCluster && Math.abs(card.position - lastCluster[0].position) < STACK_INTERVAL) {
                        lastCluster.push(card);
                    } else {
                        acc.push([card]);
                    }
                    return acc;
                }, []);

            let finalPlacedCards = [];
            groupedCards.forEach(cluster => {
                cluster.forEach((card, index) => {
                    const layer = Math.ceil(index / 2); 
                    const direction = index % 2 === 0 ? 1 : -1; 
                    const offsetMultiplier = index === 0 ? 0 : layer * direction;

                    finalPlacedCards.push({
                        ...card,
                        stackLayer: offsetMultiplier,
                    });
                });
            });
            
            return { finalPlacedCards, unplacedCards };
        }

        function mergeData(globalCards, savedRankings) {
            const savedMap = savedRankings.reduce((map, r) => {
                map[r.id] = r.position;
                return map;
            }, {});

            return globalCards.map(globalCard => ({
                ...globalCard,
                position: savedMap.hasOwnProperty(globalCard.id) ? savedMap[globalCard.id] : null, 
                isFlipped: false, 
                dimension: globalCard.dimension,
            }));
        }

        // --- RENDERING FUNCTIONS ---

        function renderCard(card, isActive, globalFlipped, continuumRef, appConfig) {
            const isPlaced = card.position !== null;
            const stackLayer = card.stackLayer || 0;
            const isFlipped = globalFlipped || card.isFlipped;

            const leftPosition = isPlaced ? `${card.position}%` : '0';
            const verticalOffset = isPlaced ? `calc(-50% + ${stackLayer * CARD_VERTICAL_OFFSET}px)` : '0';
            
            const baseClasses = `w-28 h-36 p-3 flex flex-col justify-center items-center text-sm font-medium transition-all duration-300 ease-out`;

            const placedClasses = `absolute transform -translate-x-1/2 top-1/2 rounded-xl cursor-grab active:cursor-grabbing shadow-2xl hover:shadow-4xl transition-shadow `;
            
            const activeClasses = isActive ? 'z-50 ring-4 ring-[var(--active-ring-color)] scale-[1.3] shadow-glow-dynamic' : 'z-10 hover:scale-[1.6] hover:z-50';
            
            const outerClasses = `font-sans text-center leading-snug card-3d-wrapper ${baseClasses} ${isPlaced ? placedClasses : 'bg-white shadow-lg border border-gray-100 hover:shadow-xl cursor-pointer rounded-2xl'} ${activeClasses}`;

            const description = getDescription(card.position);
            const descriptionHtml = isPlaced ? `<div class="mt-2 text-center text-blue-500 font-mono text-[10px] bg-blue-50/70 px-2 py-0.5 rounded-full shadow-inner">${description}</div>` : '';

            const style = `left: ${isPlaced ? leftPosition : '0'}; transform: ${isPlaced ? `translateX(-50%) translateY(${verticalOffset})` : 'none'};`;

            return `
                <div 
                    id="${card.id}"
                    data-card-id="${card.id}"
                    class="${outerClasses}"
                    style="${style}"
                    onpointerdown="handlePointerDown(event, this)"
                >
                    <div class="flip-container ${isFlipped ? 'flipped' : ''}">
                        
                        <!-- Card Front (Text/Description) -->
                        <div class="card-face card-front flex flex-col justify-center items-center">
                            <span class="text-gray-900">${card.text}</span>
                            ${descriptionHtml}
                        </div>

                        <!-- Card Back (Dimension) -->
                        <div class="card-face card-back flex justify-center items-center">
                            <span class="text-5xl font-extrabold text-white">${card.dimension}</span>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderApp() {
            const { config, cardData, userId, globalFlipped, activeCard } = appState;
            const continuumRef = document.getElementById('continuum-track');

            if (!cardData || cardData.length === 0) return;

            const { finalPlacedCards, unplacedCards } = calculateStackedCards(cardData);
            const totalCards = cardData.length;
            const placedCount = finalPlacedCards.length;
            const progress = totalCards > 0 ? Math.round((placedCount / totalCards) * 100) : 0;
            const allCardsPlaced = unplacedCards.length === 0;

            // 1. Update Header/Config styles
            document.getElementById('app-header').style.borderTopColor = config.primaryColor;
            document.getElementById('user-id-display').textContent = userId;
            document.documentElement.style.setProperty('--primary-color', config.primaryColor);
            document.documentElement.style.setProperty('--secondary-color', config.secondaryColor);
            document.documentElement.style.setProperty('--track-start', config.trackGradientStart);
            document.documentElement.style.setProperty('--track-end', config.trackGradientEnd);
            document.documentElement.style.setProperty('--active-ring-color', config.primaryColor);
            document.documentElement.style.setProperty('--active-glow-color', config.primaryColor);
            

            // 2. Main Content HTML Structure
            const maxStackLayer = finalPlacedCards.reduce((max, card) => 
                Math.max(max, Math.abs(card.stackLayer || 0)), 0
            );
            const minTrackHeight = 150 + (maxStackLayer * CARD_VERTICAL_OFFSET * 2); 

            const html = `
                <!-- Continuum Track -->
                <div class="mb-12 p-8 bg-white rounded-3xl shadow-3xl relative border border-gray-100">
                    <h2 class="text-2xl font-bold text-gray-700 mb-4 border-b pb-2">Your Continuum of Self-Perception (${placedCount} / ${totalCards} Placed)</h2>
                    
                    <!-- Analysis Tools (Flip Button) -->
                    ${allCardsPlaced ? `
                        <div class="mb-6 text-center space-y-4">
                            <button 
                                onclick="handleGlobalFlip()" 
                                id="global-flip-btn"
                                class="px-8 py-3 rounded-full font-bold text-lg shadow-xl transition-all duration-300 transform hover:scale-[1.03] 
                                    ${globalFlipped 
                                        ? 'text-white hover:opacity-90' 
                                        : 'bg-white text-gray-700 border-2 hover:bg-gray-50 shadow-md'}"
                                style="background-color: ${globalFlipped ? config.primaryColor : 'undefined'}; border-color: ${!globalFlipped ? config.primaryColor : 'undefined'}; color: ${!globalFlipped ? config.primaryColor : 'undefined'}"
                            >
                                ${globalFlipped ? 'Show Text (Card Front)' : 'Flip Cards for Analysis (Show Dimension)'}
                            </button>
                            <p class="text-sm text-gray-500 italic mt-2">
                                **Click any placed card to flip it individually.**
                            </p>
                        </div>
                    ` : ''}

                    <!-- Progress Bar -->
                    <div class="h-2 bg-gray-200 rounded-full mb-10 overflow-hidden">
                        <div 
                            class="h-full transition-all duration-500 ease-in-out" 
                            style="width: ${progress}%; background: linear-gradient(to right, ${config.trackGradientStart} 0%, ${config.primaryColor} 100%)"
                        ></div>
                    </div>

                    <div 
                        id="continuum-track" 
                        class="relative w-full rounded-2xl my-16 p-4 shadow-inner"
                        style="background: linear-gradient(to right, ${config.trackGradientStart} 0%, #67e8f9 50%, ${config.trackGradientEnd} 100%); min-height: ${minTrackHeight}px;"
                    >
                        <!-- Center Line Indicator -->
                        <div class="absolute top-0 left-0 right-0 h-full w-full border-x border-dashed border-gray-500/30 pointer-events-none"></div>

                        <!-- Labels for the Continuum -->
                        <div class="absolute top-full w-full flex justify-between text-base font-semibold text-gray-700 pt-5">
                            <span class="p-2 bg-white rounded-lg shadow-md -translate-x-1/2 border border-gray-200">Least Like Me (0)</span>
                            <span class="p-2 bg-white rounded-lg shadow-md left-1/2 -translate-x-1/2 absolute border border-gray-200">Neutral (50)</span>
                            <span class="p-2 bg-white rounded-lg shadow-md translate-x-1/2 border border-gray-200">Most Like Me (100)</span>
                        </div>
                        
                        <!-- Placed Cards Container -->
                        <div id="placed-cards-container">
                            ${finalPlacedCards.map(card => renderCard(card, activeCard?.id === card.id, globalFlipped, continuumRef, config)).join('')}
                        </div>
                    </div>
                </div>

                <!-- Unplaced Cards Area -->
                <div class="p-8 bg-white rounded-3xl shadow-3xl">
                    <h2 class="text-2xl font-bold text-gray-700 mb-6 border-b pb-2">Unplaced Cards (${unplacedCards.length} Remaining)</h2>
                    ${unplacedCards.length > 0 ? `
                        <div id="unplaced-cards-container" class="flex flex-wrap gap-5 justify-start">
                            ${unplacedCards.map(card => renderCard(card, activeCard?.id === card.id, globalFlipped, continuumRef, config)).join('')}
                        </div>
                    ` : `
                        <div class="p-10 bg-green-50 text-green-700 border-2 border-green-300 rounded-2xl text-center font-semibold text-xl shadow-inner">
                            <span class="text-4xl block mb-2">âœ…</span> All **${totalCards}** cards have been placed!
                        </div>
                    `}
                </div>
            `;
            
            document.getElementById('content-container').innerHTML = html;
        }

        // --- INTERACTION HANDLERS (Simulating React State) ---

        const dragStartPos = { x: 0, y: 0 };
        let saveTimeout;

        function showSaveStatus(message, isError = false) {
            const statusEl = document.getElementById('save-status');
            statusEl.textContent = message;
            statusEl.classList.remove('opacity-0', 'bg-green-100', 'text-green-700', 'bg-red-100', 'text-red-700');
            statusEl.classList.add('opacity-100', isError ? 'bg-red-100' : 'bg-green-100', isError ? 'text-red-700' : 'text-green-700');
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                statusEl.classList.remove('opacity-100');
                statusEl.classList.add('opacity-0');
            }, 2000);
        }

        function saveRanking(data) {
            try {
                const rankingsToSave = data
                    .filter(card => card.position !== null)
                    .map(card => ({ id: card.id, position: card.position }));
                
                saveUserRankings(appState.userId, rankingsToSave);
                showSaveStatus('Saved!');
            } catch (e) {
                console.error("Save Failed:", e);
                showSaveStatus('Save Failed!', true);
            }
        }
        
        function calculateNewPosition(clientX) {
            const continuumEl = document.getElementById('continuum-track');
            if (!continuumEl) return 50;

            const rect = continuumEl.getBoundingClientRect();
            const clientXInTrack = clientX - rect.left;
            const trackWidth = rect.width;

            let newPos = Math.round((clientXInTrack / trackWidth) * 100);
            newPos = Math.max(0, Math.min(100, newPos));

            return newPos;
        }

        function handlePointerDown(e, element) {
            e.preventDefault();
            e.stopPropagation(); 
            
            const cardId = element.getAttribute('data-card-id');
            let card = appState.cardData.find(c => c.id === cardId);
            if (!card) return;

            const clientX = e.clientX || e.touches?.[0]?.clientX;
            const clientY = e.clientY || e.touches?.[0]?.clientY;
            if (clientX === undefined || clientY === undefined) return;

            dragStartPos.x = clientX;
            dragStartPos.y = clientY;
            appState.hasMoved = false;

            if (!card.position) {
                const newPos = calculateNewPosition(clientX);
                card = { ...card, position: newPos };
                
                appState.cardData = appState.cardData.map(c => 
                    c.id === cardId ? card : c
                );
            }
            
            appState.activeCard = card;
            appState.isDragging = true; 
            renderApp(); // Rerender to show active state

            window.addEventListener('pointermove', handlePointerMove);
            window.addEventListener('pointerup', handlePointerUp);
        }

        function handlePointerMove(e) {
            if (!appState.isDragging || !appState.activeCard) return;

            const clientX = e.clientX || (e.touches && e.touches[0] && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY);
            if (clientX === undefined || clientY === undefined) return;

            const startX = dragStartPos.x;
            const startY = dragStartPos.y;
            
            const distance = Math.sqrt(Math.pow(clientX - startX, 2) + Math.pow(clientY - startY, 2));

            if (distance > DRAG_THRESHOLD) {
                appState.hasMoved = true; 
            } else if (!appState.hasMoved) {
                return;
            }

            const newPos = calculateNewPosition(clientX);

            appState.cardData = appState.cardData.map(c => 
                c.id === appState.activeCard.id ? { ...c, position: newPos } : c
            );
            
            appState.activeCard.position = newPos; // Update active card state
            renderApp(); // Rerender to show new position
        }

        function handlePointerUp() {
            if (!appState.isDragging || !appState.activeCard) return;

            const { activeCard, hasMoved, cardData } = appState;
            const allCardsPlaced = calculateStackedCards(cardData).unplacedCards.length === 0;

            if (hasMoved) {
                // Save the final position
                saveRanking(appState.cardData);
            } else {
                // Handle flip on tap/click
                if (activeCard.position !== null && allCardsPlaced) { 
                    appState.cardData = cardData.map(c => 
                        c.id === activeCard.id ? { ...c, isFlipped: !c.isFlipped } : c
                    );
                } else if (activeCard.position === null) {
                    // This scenario is for initial placement tap, already handled in pointer down
                    saveRanking(appState.cardData);
                }
            }
            
            appState.activeCard = null;
            appState.isDragging = false;
            appState.hasMoved = false; 
            renderApp(); // Final render

            window.removeEventListener('pointermove', handlePointerMove);
            window.removeEventListener('pointerup', handlePointerUp);
        }

        function handleGlobalFlip() {
            appState.globalFlipped = !appState.globalFlipped;
            // Reset individual flips when toggling global flip
            appState.cardData = appState.cardData.map(c => ({
                ...c,
                isFlipped: false,
            }));
            renderApp();
        }

        // --- INITIALIZATION ---

        function initApp() {
            loadAppState();
            appState.userId = getUserId();
            
            const globalCards = getServerGlobalCards();
            const savedRankings = getServerUserRankings(appState.userId);
            
            appState.globalCards = globalCards;
            appState.cardData = mergeData(globalCards, savedRankings);
            appState.config = getServerConfig();

            // Initial render
            renderApp();
        }

        // Start the application on window load
        window.onload = initApp;

    </script>
</body>
</html>